# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

"""Cursor for paging through collections"""
scalar ConnectionCursor

"""Create a new Instrument"""
input CreateInstrumentInput {
  """The name of the instrument"""
  name: String!

  """The description of the instrument"""
  description: String

  """The payload / structure of the instrument"""
  payload: JSONObject
}

input CreateOrganizationInput {
  """The name of the organization"""
  name: String!

  """The description of the organization"""
  description: String

  """The type of the organization"""
  type: String!

  """The address of the organization"""
  address: String

  """The Phone number"""
  phone: String

  """The main email address"""
  email: String

  """The URL / Website of this organization"""
  url: String

  """The logo as valid URL string)"""
  logo: String
}

"""Create a new person"""
input CreatePersonInput {
  """the pseudonym to be applied"""
  pseudonym: String!
}

input CreateScreeningInput {
  """DateTime when this screening was performed"""
  collectedAt: DateTime!

  """The language this screening was performed in"""
  language: String!

  """UserAgent Information of the device"""
  userAgent: CreateUserAgentInput
}

input CreateUserAgentInput {
  """The device type used for this request"""
  device: String

  """The OS used for this request"""
  os: String

  """The application version used for this request"""
  application: String
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

"""An Instrument resource for a survey"""
type Instrument {
  """The ID of this resource."""
  id: ID!

  """DateTime when this resource was created."""
  createdAt: DateTime!

  """DateTime when this resource was last updated."""
  updatedAt: DateTime!
  version: Float!
  name: String!

  """A description for this instrument"""
  description: String

  """An image / icon URL for this instrument"""
  image: String

  """The actual payload / content / structure of this instrument"""
  payload: JSONObject
  screenings(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ScreeningFilter = {}

    """Specify to sort results."""
    sorting: [ScreeningSort!] = []
  ): ScreeningConnection
}

type InstrumentConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [InstrumentEdge!]!
}

type InstrumentDeleteResponse {
  name: String

  """A description for this instrument"""
  description: String

  """An image / icon URL for this instrument"""
  image: String

  """The actual payload / content / structure of this instrument"""
  payload: JSONObject
}

type InstrumentEdge {
  """The node containing the Instrument"""
  node: Instrument!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

input InstrumentFilter {
  and: [InstrumentFilter!]
  or: [InstrumentFilter!]
  name: StringFieldComparison
}

input InstrumentSort {
  field: InstrumentSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum InstrumentSortFields {
  name
}

"""
The JSONObject scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Mutation {
  updateOnePerson(
    """The id of the record to update"""
    id: ID!

    """The update to apply."""
    input: UpdatePersonInput!
  ): Person!
  createOneScreening(
    """The record to create"""
    input: CreateScreeningInput!
  ): Screening!
  updateOneInstrument(
    """The id of the record to update"""
    id: ID!

    """The update to apply."""
    input: UpdateInstrumentInput!
  ): Instrument!
  createOneInstrument(
    """The record to create"""
    input: CreateInstrumentInput!
  ): Instrument!
  addScreeningsToInstrument(
    """The id of the record."""
    id: ID!

    """The ids of the relations."""
    relationIds: [ID!]!
  ): Instrument!
  updateOneOrganization(
    """The id of the record to update"""
    id: ID!

    """The update to apply."""
    input: UpdateOrganizationInput!
  ): Organization!
  createOneOrganization(
    """The record to create"""
    input: CreateOrganizationInput!
  ): Organization!
  createOnePerson(
    """The record to create"""
    input: CreatePersonInput!
  ): Person!
}

"""An Organization resource"""
type Organization {
  """The ID of this resource."""
  id: ID!

  """DateTime when this resource was created."""
  createdAt: DateTime!

  """DateTime when this resource was last updated."""
  updatedAt: DateTime!
  version: Float!
  name: String!

  """A description of this organization"""
  description: String
  type: String!

  """The address of this organization"""
  address: String

  """The phone number of this organization"""
  phone: String

  """An email address of this organization"""
  email: String

  """The URL / website of this organization"""
  url: String

  """The URL for the logo of this organization"""
  logo: String
}

type OrganizationConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [OrganizationEdge!]!
}

type OrganizationDeleteResponse {
  name: String

  """A description of this organization"""
  description: String
  type: String

  """The address of this organization"""
  address: String

  """The phone number of this organization"""
  phone: String

  """An email address of this organization"""
  email: String

  """The URL / website of this organization"""
  url: String

  """The URL for the logo of this organization"""
  logo: String
}

type OrganizationEdge {
  """The node containing the Organization"""
  node: Organization!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

input OrganizationFilter {
  and: [OrganizationFilter!]
  or: [OrganizationFilter!]
  name: StringFieldComparison
  type: StringFieldComparison
}

input OrganizationSort {
  field: OrganizationSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum OrganizationSortFields {
  name
  type
}

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

"""A person"""
type Person {
  """The ID of this resource."""
  id: ID!

  """DateTime when this resource was created."""
  createdAt: DateTime!

  """DateTime when this resource was last updated."""
  updatedAt: DateTime!
  version: Float!
  pseudonym: String!

  """indicates if the TOS were accepted"""
  acceptedTOS: Boolean!
}

type PersonConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PersonEdge!]!
}

type PersonDeleteResponse {
  pseudonym: String

  """indicates if the TOS were accepted"""
  acceptedTOS: Boolean
}

type PersonEdge {
  """The node containing the Person"""
  node: Person!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

input PersonFilter {
  and: [PersonFilter!]
  or: [PersonFilter!]
  pseudonym: StringFieldComparison
}

input PersonSort {
  field: PersonSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PersonSortFields {
  pseudonym
}

type Query {
  person(id: ID!): Person
  people(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PersonFilter = {}

    """Specify to sort results."""
    sorting: [PersonSort!] = []
  ): PersonConnection!
  screening(id: ID!): Screening
  screenings(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: ScreeningFilter = {}

    """Specify to sort results."""
    sorting: [ScreeningSort!] = []
  ): ScreeningConnection!
  instrument(id: ID!): Instrument
  instruments(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: InstrumentFilter = {}

    """Specify to sort results."""
    sorting: [InstrumentSort!] = []
  ): InstrumentConnection!
  organization(id: ID!): Organization
  organizations(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: OrganizationFilter = {}

    """Specify to sort results."""
    sorting: [OrganizationSort!] = []
  ): OrganizationConnection!
}

"""A processed screening"""
type Screening {
  """The ID of this resource."""
  id: ID!

  """DateTime when this resource was created."""
  createdAt: DateTime!

  """DateTime when this resource was last updated."""
  updatedAt: DateTime!
  version: Float!

  """DateTime when this screening was performed."""
  collectedAt: DateTime!
  language: String!
  instrument: Instrument
  person: Person

  """UserAgent information"""
  userAgent: UserAgent
}

type ScreeningConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [ScreeningEdge!]!
}

type ScreeningDeleteResponse {
  """DateTime when this screening was performed."""
  collectedAt: DateTime
  language: String
}

type ScreeningEdge {
  """The node containing the Screening"""
  node: Screening!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

input ScreeningFilter {
  and: [ScreeningFilter!]
  or: [ScreeningFilter!]
  collectedAt: DateFieldComparison
  language: StringFieldComparison
}

input ScreeningSort {
  field: ScreeningSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum ScreeningSortFields {
  collectedAt
  language
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

input StringFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: String
  neq: String
  gt: String
  gte: String
  lt: String
  lte: String
  like: String
  notLike: String
  iLike: String
  notILike: String
  in: [String!]
  notIn: [String!]
}

"""Update an existing Instrument"""
input UpdateInstrumentInput {
  """The (new) name of this instrument"""
  name: String

  """The (new) description of this instrument"""
  description: String

  """The (new) payload / structure of the instrument"""
  payload: JSONObject
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateOrganizationInput {
  """The (new) name of the organization"""
  name: String

  """The (new) description of the organization"""
  description: String

  """The (new) type of the organization"""
  type: String

  """The (new) address"""
  address: String

  """The (new) phone number"""
  phone: String

  """The (new) email address"""
  email: String

  """The (new) URL"""
  url: String

  """The (new) logo URL"""
  logo: String
}

"""Update a person"""
input UpdatePersonInput {
  """if the person has accepted the TOS"""
  acceptedTOS: Boolean!
}

input UpdateScreening {
  """DateTime when this screening was performed."""
  collectedAt: DateTime
  language: String
}

type UserAgent {
  """The device type used for this request"""
  device: String

  """The OS used for this request"""
  os: String

  """The application version used for this request"""
  application: String
}
